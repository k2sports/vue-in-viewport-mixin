// Generated by CoffeeScript 1.12.5

/*
Determines if the view is in visible in the browser window.

Example usage:
	Just require the mixin from your component.
	Use the optional offset props like:

	large-copy(
		:in-viewport-offset-top="300"
		:in-viewport-offset-bottom="0.5"

		 * Only add the `in-viewport` class once per page load
		:in-viewport-once="false"
	)
 */

(function() {
  var check, win;

  win = require('window-event-mediator');

  check = require('./check');

  module.exports = {
    props: {
      inViewportActive: {
        type: 'Boolean',
        "default": true
      },
      inViewportOnce: {
        type: 'Boolean',
        "default": true
      },
      inViewportClass: {
        type: 'string',
        "default": 'in-viewport'
      },
      inViewportEntrelyClass: {
        type: 'string',
        "default": 'in-viewport-entirely'
      },
      inViewportOffsetTop: {
        type: Number,
        "default": 0
      },
      inViewportOffsetBottom: {
        type: Number,
        "default": 0
      }
    },
    data: function() {
      return {
        inViewport: false,
        inViewportEntirely: false,
        aboveViewport: false,
        belowViewport: false
      };
    },
    ready: function() {
      if (this.inViewportActive) {
        return this.addInViewportHandlers();
      }
    },
    destroyed: function() {
      return this.removeInViewportHandlers();
    },
    watch: {
      inViewportActive: function(ready) {
        if (ready) {
          return this.addInViewportHandlers();
        }
      },
      inViewport: function(visible) {
        if (this.inViewportOnce && visible) {
          this.removeInViewportHandlers();
        }
        if (this.inViewportClass) {
          return $(this.$el).toggleClass(this.inViewportClass, visible);
        }
      },
      inViewportEntirely: function(visible) {
        if (this.inViewportEntrelyClass) {
          return $(this.$el).toggleClass(this.inViewportEntrelyClass, visible);
        }
      }
    },
    methods: {
      onInViewportScroll: function() {
        var prop, ref, results, val;
        ref = check(this.$el, {
          offsetTop: this.inViewportOffsetTop,
          offsetBottom: this.inViewportOffsetBottom
        });
        results = [];
        for (prop in ref) {
          val = ref[prop];
          results.push(this[prop] = val);
        }
        return results;
      },
      addInViewportHandlers: function() {
        if (this.inViewportHandlersAdded) {
          return;
        }
        this.inViewportHandlersAdded = true;
        win.on('scroll', this.onInViewportScroll, {
          throttle: 0
        });
        win.on('resize', this.onInViewportScroll);
        return this.onInViewportScroll();
      },
      removeInViewportHandlers: function() {
        if (!this.inViewportHandlersAdded) {
          return;
        }
        this.inViewportHandlersAdded = false;
        win.off('scroll', this.onInViewportScroll);
        return win.off('resize', this.onInViewportScroll);
      },

      /*
      		 * Public API for invoking visibility tests
       */
      isInViewport: function(el, options) {
        return check(el, options).inViewport;
      },
      isInViewportEntirely: function(el, options) {
        return check(el, options).isInViewportEntirely;
      }
    }
  };

}).call(this);
